PSEUDO CODE FOR MINESWEEPER

GLOBAL VARIABLES:
    board[HEIGHT][WIDTH] - internal board storing mine positions (char array)
    display_board[HEIGHT][WIDTH] - what player sees (char array)
    game_over - true/false if game ended
    won - true/false if player won
    first_move - true if first click hasn't happened yet

DEFINE CONSTANTS:
    HIDDEN = '.'    (empty cell that's hidden)
    MINE = '*'      (cell with mine)
    REVEALED = '0'  (revealed empty space with adjacent mine count)
    FLAGGED = 'F'   (player flagged this square)
    MISS = 'X'      (miss marker)

INITIALIZE GAME:
    set all board squares to HIDDEN
    set all display_board squares to HIDDEN
    set game_over = false
    set won = false
    set first_move = true
    seed random number generator

COUNT ADJACENT MINES FUNCTION (x, y):
    count = 0
    for each direction (up, down, left, right, and all diagonals):
        new_x = x + direction_x
        new_y = y + direction_y
        if new_x and new_y are within board boundaries:
            if board[new_y][new_x] equals MINE:
                count = count + 1
    return count

PLACE MINES FUNCTION (safe_x, safe_y):
    mines_placed = 0
    while mines_placed < MINES:
        random_x = random number between 0 and WIDTH-1
        random_y = random number between 0 and HEIGHT-1
        if (random_x, random_y) is not the safe square AND board[random_y][random_x] is not MINE:
            set board[random_y][random_x] to MINE
            mines_placed = mines_placed + 1

REVEAL FUNCTION (x, y):
    if x,y is outside board boundaries: return
    if display_board[y][x] is not HIDDEN: return (already revealed or flagged)

    if this is first move EVER made in the game:
        call PLACE MINES FUNCTION (with x,y as safe square)
        set first_move = false

    if board[y][x] equals MINE: (clicking mine)
        set game_over = true
        set display_board[y][x] = MINE (show the mine that was hit)
        return

    USE ITERATIVE FLOOD FILL for revealing empty areas:
    create queue array of size (WIDTH * HEIGHT * 2) for storing x,y pairs
    front = 0 (read position in queue)
    rear = 0 (write position in queue)
    
    add initial x to queue[rear], increment rear
    add initial y to queue[rear], increment rear

    while front < rear (queue not empty):
        current_x = queue[front], increment front
        current_y = queue[front], increment front

        if display_board[current_y][current_x] is not HIDDEN: continue (skip if already processed)

        mine_count = COUNT ADJACENT MINES FUNCTION (current_x, current_y)
        if mine_count is 0: set display_board[current_y][current_x] to ' ' (space)
        else: set display_board[current_y][current_x] to character ('0' + mine_count)

        if mine_count is 0 (empty area, flood fill to neighbors):
            for each adjacent square (8 directions, excluding center):
                new_x = current_x + direction_x
                new_y = current_y + direction_y
                if new_x, new_y is within bounds AND display_board[new_y][new_x] is HIDDEN AND board[new_y][new_x] is not MINE:
                    add new_x to queue[rear], increment rear
                    add new_y to queue[rear], increment rear

FLAG FUNCTION (x, y):
    if x,y is outside board boundaries: return
    if display_board[y][x] is not HIDDEN and not FLAGGED: return (can't flag revealed squares)
    
    if display_board[y][x] equals HIDDEN:
        set display_board[y][x] to FLAGGED
    else if display_board[y][x] equals FLAGGED:
        set display_board[y][x] back to HIDDEN (toggle off the flag)

CHECK WIN FUNCTION:
    revealed_count = 0
    total_safe = WIDTH * HEIGHT - MINES
    for each square on board:
        if display_board[y][x] is not HIDDEN and display_board[y][x] is not FLAGGED:
            revealed_count = revealed_count + 1
    if revealed_count equals total_safe: return true (won - all safe squares revealed)
    else: return false (not won yet)

COUNT FLAGS FUNCTION:
    count = 0
    for each square on board:
        if display_board[y][x] equals FLAGGED: count = count + 1
    return count

DRAW BOARD FUNCTION:
    count_flags = COUNT FLAGS FUNCTION
    print "Mines: [MINES], Flags: [count_flags], "
    if game_over and won: print "YOU WIN!"
    else if game_over: print "GAME OVER!"
    print newline, newline
    
    print column numbers across top (0 through WIDTH-1, modulo 10)
    for each row (0 through HEIGHT-1):
        print row number on left (modulo 10)
        for each square in row:
            print display_board[y][x] followed by space
        print newline
    print newline

PROCESS INPUT FUNCTION:
    print "Command (r row col=Reveal, f row col=Flag, q=Quit): "
    read input from user
    
    if input matches "command row col" pattern:
        parse command, row, col from input
        if row or col are outside valid range (0 to HEIGHT-1 or 0 to WIDTH-1):
            print error message about invalid coordinates
            return 1 (continue game)
        
        if command is 'r' or 'R' (reveal):
            call REVEAL FUNCTION (col, row)  // convert (row, col) input to (x, y)
        else if command is 'f' or 'F' (flag):
            call FLAG FUNCTION (col, row)   // convert (row, col) input to (x, y)
        else:
            print "Invalid command!" message
            return 1 (continue)
            
    else if input is just a single character:
        if character is 'q' or 'Q' (quit):
            return 0 (stop game)
        else:
            print invalid command message
            return 1 (continue)
    else:
        print invalid input format message
        return 1 (continue)
    
    return 1 (continue playing)

GAME CONTINUE FUNCTION:
    if game_over is true:
        if won is true: print "You won!"
        else: print "You hit a mine!"
        return 0 (game should stop)
    
    call CHECK WIN FUNCTION
    if CHECK WIN returns true:
        set won = true
        set game_over = true
        return 1 (continue to show final win state)
    
    return 1 (game continues)

MAIN GAME LOOP:
    print welcome message and game info
    call INITIALIZE GAME
    
    while GAME CONTINUE FUNCTION returns 1:
        call DRAW BOARD FUNCTION
        if PROCESS INPUT FUNCTION returns 0: break (user quit)
    
    call DRAW BOARD FUNCTION one final time (show final state)
    print "Thanks for playing!"
